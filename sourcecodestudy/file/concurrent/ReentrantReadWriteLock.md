# 读写锁ReentrantReadWriteLock

读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得**并发性相比一般的排他锁有了很大提升**。除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够**简化读写交互场景的编程方式**。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。
一般情况下，读写锁的性能都会比排它锁好，因为**大多数场景读是多于写的**。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量

当线程获取读锁其他线程对于读锁和写锁均被阻塞

### 读写锁的特性

* 支持公平性选择，默认非公平，非公平优于公平
* 支持重进入
* 支持锁降级，写锁能降级成读锁

### 读写状态
源码中有一个state成员变量就是用来表示当前状态，高16位标示读，低16位标示写

    private volatile int state;

我们看到源码中有下面几个常量

        static final int SHARED_SHIFT   = 16;//32位的中间位
        static final int SHARED_UNIT    = (1 << SHARED_SHIFT);//写锁的移动单位，每当一个线程获取写锁state基础上加上这个值
        static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
        static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;



* 读状态

每当一个线程获取读锁则在SHARED_UNIT加上state，
SHARED_UNIT：维护读状态的整数，初始值的二进制000(前面共16个0)1000000000000000（后面15个0）

* 写状态

写状态不可共享所以一般只会有同个线程多次进入，每次state+1

